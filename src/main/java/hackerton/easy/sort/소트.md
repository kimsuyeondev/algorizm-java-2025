퀵정렬 공식 
퀵정렬 마지막에라도 다시한번보자ㅏㅏ
pivot = 마지막 요소
partition으로 피벗 자리 찾기
왼쪽 정렬
오른쪽 정렬
Lomuto Partition 공식
i = low
j는 low~high-1
a[j] ≤ pivot → swap(a[i], a[j]), i++
마지막에 swap(a[i], a[high])

시간 복잡도
평균: O(n log n)
최악: O(n²)

    private static int quickSort(int[] a, int low, int high) {
        if (low >= high) return 0;
        // partition은 [pivotIndex, partition에서 발생한 swap 수]를 리턴
        int[] result = partition(a, low, high);
        int pivotIndex = result[0];
        int swapsHere = result[1];

        int swapsLeft = quickSort(a, low, pivotIndex - 1);
        int swapsRight = quickSort(a, pivotIndex + 1, high);
        return swapsHere + swapsLeft + swapsRight;
    }
