BFS: Queue + 거리 1씩 증가
다익스트라: PriorityQueue + 비용이 작은 노드부터 뽑기
. 개념 먼저: 가중치 BFS = 다익스트라라고 보면 됨
네가 지금까지 한 건:
BFS
간선(이동) 비용이 모두 1
→ “몇 번 이동?” = 큐로 레벨 탐색
근데 현실에서는:
교차로 A→B 가는 비용 = 3초
A→C 가는 비용 = 10초
C→D 가는 비용 = 1초
… 이런 식으로 간선마다 비용이 다름
이럴 때는:
“한 칸 = 1” 이 아니니까
BFS 큐로는 최단 경로 보장이 안 돼.
그래서 쓰는 게
우선순위 큐를 사용하는 BFS = 다익스트라(Dijkstra)
이라고 생각하면 된다.
요약하면:
BFS: Queue + 거리 1씩 증가
다익스트라: PriorityQueue + 비용이 작은 노드부터 뽑기
---ㅃ
그럼 “그리드(격자)에서 최소 비용 경로”는 뭐야?
1) 그래프 구조가 나오면 → 다익스트라(또는 BFS)
2) “배열 인덱스를 변화하면서 최적값 쌓는 구조” → DP
   예:
   1 3 1
   2 5 1
   4 2 1
   여기서 최소 비용 경로 구하기는
   DP로도 풀리고, 다익스트라로도 풀려.
   왜?
   이동 방향이 오직 오른쪽/아래만 가능하다면 → DP로 해결 가능
   이동이 상/하/좌/우 가능한 일반 그래프면 → DP로는 못 함, 다익스트라만 가능
   즉,
   방향이 제한된 격자 → DP 가능
   방향이 자유로운 격자 → 다익스트라만 가능
--------
2. 문제 세팅 (그리드 버전 – 이해용)
먼저 2D 격자 버전으로 연습해보자.
각 칸에 cost[i][j] (해당 칸에 들어갈 때 드는 비용)가 있고,
(0,0) 에서 시작해서 (n-1, m-1)까지
도착할 때까지의 최소 비용 합을 구해라.
이동: 상/하/좌/우
예시:

cost = [
[1, 3, 1],
[2, 5, 1],
[4, 2, 1]
]
가능한 경로 중 하나:
1 → 3 → 1 → 1 → 1 = 7 (최소)
3. 다익스트라 핵심 로직 (그리드 버전)
아이디어:
dist[r][c] : (0,0)에서 (r,c)까지의 현재까지 알려진 최소 비용
시작점 dist[0][0] = cost[0][0]
우선순위 큐(PQ)에 (비용, r, c) 넣고,
항상 비용이 가장 작은 칸부터 꺼내서
그 칸에서 상/하/좌/우로 “완화(relax)” 한다
더 싸게 가는 방법을 발견하면 갱신하고 PQ에 다시 삽입
(n-1, m-1)에 도착하면 그게 최소 비용
