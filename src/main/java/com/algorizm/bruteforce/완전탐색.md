① DFS/BFS = 완전탐색의 한 종류
그래프 탐색에서 DFS/BFS 로 모든 경우를 확인하는 원리 자체가 완전탐색이야.
완전탐색을 알아야 DFS가 이해됨
DFS를 알아야 백트래킹이 이해됨
백트래킹을 알아야 조합/경로/최적화가 이해됨
즉,
완전탐색 → DFS → 백트래킹 → DP/최적화
이 흐름이 기본이다.

1) 완전탐색의 정의
가능한 모든 경우를 전부 확인하는 알고리즘.
예)
숫자 1~9를 모두 조합해본다
경로를 모든 방향으로 가본다
문자열 모든 부분을 확인한다
모든 기사 중 조건을 충족하는 기사 다 본다
2) 시간 복잡도 감
브루트포스는 큰 입력에서 터진다.
그래서:
N = 10 → 2^N = OK
N = 20 → 1,000,000 = OK
N > 20 → DFS/백트래킹/DP 필요
이 정도 감만 있으면 충분해.

3) 완전탐색 코드는 그냥 이 패턴이면 끝
(1) for 중첩 패턴 (작은 케이스)
for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
        // 모든 경우 보는 중
    }
}

(2) DFS 패턴 (경로 완전탐색)
dfs(node) {
    for (next : graph[node]) {
        if (!visited[next]) dfs(next);
    }
}

(3) 백트래킹 패턴 (조합/순열)
void dfs(int depth) {
    if (depth == target) {
        // 완성된 경우
        return;
    }
    for (int i = 0; i < N; i++) {
        if (!visited[i]) {
            visited[i] = true;
            dfs(depth + 1);
            visited[i] = false;
        }
    }
}
이 3개가 완전탐색의 전부라고 해도 된다.
결론
완전탐색은 “기본 원리”라서 꼭 알아야 한다
하지만 실제 풀이에서 완전탐색만 쓰는 문제는 거의 없다
완전탐색 → DFS/BFS → DP 로 이어지는 구조를 이해하는 것이 핵심
    경로 개수 세기 (DFS + DP)
완전탐색 개념 + 기본 코드 3개만 알면 충분


---
완전탐색이 뭐냐?
한 줄 정의로 말하면:
나올 수 있는 모든 경우를 전부 만들어 보고, 그중에서 답을 고르는 방법
좀 더 현실적으로 말하면:
“어떻게 하면 똑똑하게 풀지?” → x
“그냥 나올 수 있는 경우를 싹 다 돌려보자.” → 
그래서 영어로 Brute-force (무식하게 힘으로) 라고 부르는 거고,
국룰은:
경우의 수가 크지 않을 때만 쓸 수 있다. (10!, 2^20 이런 정도까지)
구현이 단순해서 버그가 적고, 아이디어 검증용으로 최고.

2. 언제 완전탐색을 쓰냐?
이런 문제들에서 잘 맞아:
“모든 순열”, “모든 조합”, “모든 부분집합” 중 최댓값/최솟값 구하기.
“모든 경로를 다 보면서 가장 좋은 경로” 찾기 (단, N이 작을 때).
특정 기간 동안 날짜를 하루씩 진행하면서 요금/상태 합산
여러 쿠폰/규칙 중 “모든 조합”은 아니고, 모든 날, 모든 이벤트를 순서대로 처리
“정해진 범위 안에서 전부 돌려도 시간 충분한 경우”

3. 완전탐색 기본 패턴들
사실 완전탐색은 크게 4가지 패턴으로 정리할 수 있어:
단순 for 중첩 루프
재귀(DFS)를 이용한 순열/조합
비트마스크로 부분집합 모두 보기 
시뮬레이션형 완전탐색 (날짜/좌표를 하나씩 전진)

3-1. 단순 for 중첩 루프
예: 배열에서 두 수를 골라 합이 최대인 경우
int[] arr = {5, 9, 1, 3};
int maxSum = Integer.MIN_VALUE;
for (int i = 0; i < arr.length; i++) {
    for (int j = i + 1; j < arr.length; j++) {
        int sum = arr[i] + arr[j];
        maxSum = Math.max(maxSum, sum);
    }
}
System.out.println(maxSum); // 9+5 = 14
경우의 수: nC2 → O(n^2)
“조금만 생각하면 최댓값은 정렬해서 두 개 뽑으면 되지 않나?” → 그리디
하지만 완전탐색으로 하면 항상 정답이긴 함.
--- 
3-2. 재귀(DFS)로 모든 경우 만들기 – 순열/조합

예: 숫자 3개 [1,2,3]로 만들 수 있는 모든 순서(순열)
// 답: [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]
public class PermutationGenerate {
static List<List<Integer>> result = new ArrayList<>();
static boolean[] used = new boolean[3];
static int[] nums = {1, 2, 3};
      public static void main(String[] args) {
          dfs(new ArrayList<>());

          System.out.println("=== 모든 순열 ===");
          for (List<Integer> perm : result) {
              System.out.println(perm);
          }
          System.out.println("총 " + result.size() + "개");
      }

      static void dfs(List<Integer> path) {
          if (path.size() == 3) {
              result.add(new ArrayList<>(path));
              return;
          }

          for (int i = 0; i < 3; i++) {
              if (used[i]) continue;
              used[i] = true;
              path.add(nums[i]);
              dfs(path);
              path.remove(path.size() - 1);
              used[i] = false;
          }
      }
}
가능한 순열: 3! = 6개
이렇게 모든 경우를 만들어서 그중 조건 맞는 것만 고르거나, 최대/최소를 갱신하는 것이 완전탐색+DFS 패턴.

3-3. 비트마스크로 부분집합 전체 보기

예: n개의 원소에 대해 “포함/미포함” 2가지 선택 → 경우의 수: 2^n

int[] nums = {3, 5, 7};
int n = nums.length;

for (int mask = 0; mask < (1 << n); mask++) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        if ((mask & (1 << i)) != 0) { // i번째 원소 사용
            sum += nums[i];
        }
    }
    System.out.println("subset sum = " + sum);
}
이건 정통 알고리즘 문제에서나 나오고,
사용 가능성이 그렇게 높진 않지만 기본 개념 알아두면 좋아.

4. 완전탐색의 핵심 포인트 (면접/코테용 키워드)
“경우의 수가 작을 때는 완전탐색이 정답이다”
→ 괜히 그리디/DP 찾다 삽질하는 것보다, 깔끔하게 완전탐색이 더 안전한 경우 많음
시간복잡도 계산만 할 줄 알면 된다
중첩 for 두 개 → O(n^2)
3중 for → O(n^3)
순열 → O(n!)
부분집합 → O(2^n)
완전탐색 + 가지치기(pruning)
→ “여기부터는 봐도 의미 없다” 싶은 경우는 중간에 잘라서 속도 개선

