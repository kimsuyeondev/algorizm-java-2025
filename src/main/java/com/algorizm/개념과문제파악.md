개념 + 언제 쓰는지 + 문제에서 바로 구분하는 법
상황	                                            | 쓰는 알고리즘
---------------------------------------------------------------------
연결되어 있는지 탐색 / 영역 찾기	                    | DFS 또는 BFS
최단 거리(가장 적은 이동 횟수) 거리나비용일정1             | BFS
일정치않을때 최단시간거리                              | 가중치 BFS = 다익스트라
현재 선택이 미래에 영향 없음 → 그 순간 가장 좋은 선택	    | Greedy
예전 결과를 재사용해서 최적값 계산해야 할 때	            | DP
가장 작은/큰/우선순위 높은 애를 즉시 뽑아야 할 때	        | PriorityQueue
최근 T초 / 최근 K개 구간 처리 필요할 때	                | Sliding Window
정확히 1개만 뽑기 or 상위 K개 뽑기	PQ or 정렬           | PQ or 정렬
-------------
▶ DFS로 해결하는 문제
섬 개수 세기
연결된 영역 개수 세기
트리 순회
백트래킹 조합 탐색
그래프가 연결되어 있는지 검사
▶ BFS로 해결하는 문제
최소 이동 횟수 (미로 이동)
최소 연산 횟수 (ex. 1 → N 만들기)
최단 거리 hop count
전염(감염) 퍼지기
레벨 순회(level order traversal)
---------------
 BFS VS DP
BFS는 ‘거리(단계)’가 모두 동일할 때 최단 거리를 구하고, DP는 ‘비용/경로/선택의 경우의 수 등 복잡한 최적값’을 구한다.
BFS = “모든 간선 비용이 동일할 때 최소 거리 탐색”
예: 미로에서 상하좌우 이동은 모두 “한 칸 이동 = 1”
(0,0) → (2,2) 최소 몇 번 이동하면 되나요?
→ 이건 BFS 최단거리 문제다.
이동 비용이 항상 동일(=1)
가까운 것부터 퍼져나가면
먼저 도착한 경로가 최단 거리가 되기 때문
즉, BFS는 계산량 없이 자동으로 최적값이 나온다.

-> 비용이 1이아니라면 dp나 다익스트라!! 가중치 BFS = 다익스트라
1) 그래프 구조가 나오면 → 다익스트라(또는 BFS) 상하좌우~가능 
우선순위 큐를 사용하는 BFS = 다익스트라(Dijkstra) 

2) “배열 인덱스를 변화하면서 최적값 쌓는 구조” → DP 
DP = “비용/경로/선택이 제각각일 때 최적값 계산”
예:
최소 피로도
최소 점프 비용
최대 합
최저 비용
방법의 개수
문자열 최소 편집
점수 최적화
재귀적 선택 최적값
이런 것들은
비용(cost)이 전부 다르기 때문에:
“가까워도 비용이 높을 수 있음.”
“멀어도 비용이 낮을 수 있음.”
--------------
그럼 “그리드(격자)에서 최소 비용 경로”는 뭐야?
1) 그래프 구조가 나오면 → 다익스트라(또는 BFS)
2) “배열 인덱스를 변화하면서 최적값 쌓는 구조” → DP
   예:
   1 3 1
   2 5 1
   4 2 1
   여기서 최소 비용 경로 구하기는
   DP로도 풀리고, 다익스트라로도 풀려. 
   왜?
   이동 방향이 오직 오른쪽/아래만 가능하다면 → DP로 해결 가능
   이동이 상/하/좌/우 가능한 일반 그래프면 → DP로는 못 함, 다익스트라만 가능
   즉,
   방향이 제한된 격자 → DP 가능
   방향이 자유로운 격자 → 다익스트라만 가능
--------------
1. DFS (Depth First Search)

“갈 수 있는 곳까지 쭉 내려갔다가 막히면 뒤로 돌아오는 탐색”

언제 쓰는지? (문제를 보면 어떻게 구분?)
문제에 다음 단어가 있으면 무조건 DFS야:
“연결됨”  “이어져 있다”  “섬 개수 세기” “방문” “네트워크 개수” “트리 구조 검증” “그래프”
즉, “이어져 있는 구조를 탐색하라” → DFS
→ 깊이 우선
→ 재귀
→ 스택
→ 영역 탐색, 연결된 조각 찾기, 백트래킹

2. BFS (Breadth First Search)
BFS
"가까운 곳부터 차례대로 훑는 탐색"
→ 너비/거리 우선
→ 큐
→ 최단 거리, 레벨 탐색
시작점을 큐에 넣고
꺼내서(가장 가까운 노드)
그 주변(이웃)을 큐에 넣고
가까운 것부터 차례대로 탐색

2. Greedy (그리디)

“현재 시점에서 가장 좋은 선택을 하면 전체도 좋아진다.”

문제에서 어떻게 구분?
문제를 읽다가 이런 느낌이면 모두 Greedy:
“가장 작은 것 먼저” “가장 가까운 것부터 배정” “가장 큰 / 높은 / 낮은… 순서로” “가장 효율적인 선택” “순간 최선의 선택”
그리디는 보통 정렬과 세트로 등장해.
대표 코드
Collections.sort(items);
for (item : items) {
if (조건 만족) pick(item);
}
그리디 문제?
기사 배차: 거리 → 평점 순으로 “즉시” 최적 기사 선택
→ 이건 PQ지만 본질은 Greedy
요청 처리: 빨리 끝나는 것부터 처리

3. DP (Dynamic Programming)
가장 어려워 보이지만,
사실 DP는 딱 두 가지에서만 나온다.
DP 개념 단 한 줄
“이전 계산 결과를 재사용해서 최적값을 만든다.”
DP인지 어떻게 구분?
문제에서 다음 단어가 나오면 100% DP:
“최소 비용”  “최대 점수”  “최적의 방법” “이전 결과를 토대로” “누적” “~까지의 최적값” “부분 문제”
또는 표처럼 dp[i] = dp[i-1] + … 형태로 이어지는 경우.

dp[i] = 문제의 i번째까지의 최적값
dp[i] = min(dp[i-1] + costA, dp[i-2] + costB)

 실제 나올 법한 DP 패턴
특정 시간대별 비용 최적화
주행 경로의 최소 비용
연속된 조건을 만족하는 최대 길이
하루/시간 단위 누적 최적값

4. Sliding Window (슬라이딩 윈도우)
“최근 T초 / 최근 K개의 범위만 유지하고 나머지는 버리는 방식”
문제에서 어떻게 구분?
문제에 다음이 포함되면 100% sliding window야:
“최근 N초 동안”
“지난 1분(60초) 안에”
“최근 K개”
“윈도우”
“시간 제한”
대표 코드
while (!q.isEmpty() && q.peek() < time - window + 1) {
    q.poll();
}
q.offer(time);

 3번에서 실제로 자주 나오는 유형
Throttle 문제
(10초, 60초 안에 최대 M개 요청 허용)

5. Priority Queue (우선순위 큐)
“가장 작은(또는 큰) 애를 바로 꺼내는 자료구조”
문제에서 어떻게 구분? (너가 제일 잘함)
문제에 이런 조건 있으면 PQ:
“가장 ~한 1명 선택”  “상위 K명”  “우선순위 순으로”  “즉시 가장 좋은 후보”

6. 정렬(Sort) + 필터링
 제일 자주 나오는 형태:
조건으로 필터링
여러 필드 기준 정렬
앞에서부터 greedy하게 뽑기
이건 Greedy + Sort 조합.



Greedy 문제 (회의실 배정 / 가장 가까운 기사 배정)
DP 문제 (최소 피로도 / 계단 최소 비용)
BFS 문제 (최단 거리 이동)
다익스트라 + PQ 문제 (가중치 최단거리)
슬라이딩 윈도우 문제 (최근 T초 요청 수 제한)
