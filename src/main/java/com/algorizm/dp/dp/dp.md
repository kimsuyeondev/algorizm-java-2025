DP = 이전 결과를 재사용해서 현재 최적값을 계산하는 방법

DP는 딱 3개만 알면 끝
DP 1: 연속 부분 최적 (Kadane’s Algorithm 류)
핵심 패턴:
dp[i] = Math.max(dp[i-1] + arr[i], arr[i]);
“연속된 구간 중 최댓값/최솟값/최대 길이 찾기”
“연속된 일자 중 최대 근무 시간”
“연속된 구간에서 최대 합”
“연속된 요청 중 조건 만족하는 최대 길이”

DP(동적 계획)

백엔드에서는 복잡한 DP(DP on trees, knapsack depth N) 절대 안 나와.
하지만 다음 두 개는 실제 후기에 몇 번 등장함.
DP 유형 1: 1차원 DP (배열 채우기)
예:
비용 최소화  
연속 구간 처리  
부분 문자열  
최소 점프  
연속된 조건을 만족하는 부분 구간  
형태:  
dp[i] = i번째까지의 최적값
dp[i] = min(dp[i-1] + 비용A, dp[i-2] + 비용B)

“연속된 일자 중 최대 근무 시간”
“연속된 구간에서 최대 합”
“연속된 요청 중 조건 만족하는 최대 길이”
dp[i] = Math.max(dp[i-1] + arr[i], arr[i]);

간단 예: 최소 비용 이동
dp[0] = cost[0];
for (int i = 1; i < N; i++) {
dp[i] = Math.min(dp[i-1], dp[i-2]) + cost[i];

DP 2: 누적 최적(1차원 DP)
예:
“i번째까지의 최소 비용” 같은 문제

“i번째 요청까지 처리할 때 최소 비용”
“i일까지 최소 이동 비용”
“각 규칙을 적용했을 때 누적 최솟값/최댓값”
핸드폰 요금 계산 문제처럼 생긴 형식
dp[i] = Math.min(dp[i-1] + costA, dp[i-2] + costB);

이런 “1차원 DP”는 백엔드에서도 나올 수 있어
(로그 처리, 비용 누적, 최단 처리 시간 등)
 DP 유형 2: 파싱/조건 충족 여부
문자열 분할, 연속 조건 판별 dp
예:
블록을 나누는 최소 조각 수
특정 패턴이 연속해서 등장하는 구간 count
(A,B,C 조건 충족하는 구간 최대 길이)
형태:
dp[i] = dp[i-1] + 1 (조건 만족)
dp[i] = 0 (조건 불만족)

DP 3: 경로 누적 (2D DP)
예:
“왼→오른쪽 아래 방향으로 이동할 때 최소 비용”
문제 느낌:
“지도에서 최단 거리” (하지만 BFS가 더 많음)
“주행 경로 비용 계산” 등
패턴:
dp[i][j] = A[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);


---
햄버거 비유 (초간단!)
너가 i번째 햄버거 가게에 도착하고 싶어.
갈 수 있는 길은:
바로 앞 가게(i-1)에서 오거나
그 앞(i-2)에서 점프해서 오거나
그래서 i에 도착하기 전에 dp 값은 항상 이렇게 생겨:
dp[i] = min(앞에서온비용, 2칸앞에서온비용) + 현재가게비용

이게 DP 공식의 진짜 정체야.
진짜 핵심 요약
DP 공식은 절대 외우는 게 아니다.
항상 'i에 오기 직전의 위치'를 나열하면 자연스럽게 나온다.
그래서:
1칸/2칸 이동 → dp[i-1], dp[i-2]
1분전/10초전 → dp[i-1]
A→B→C 경로 → dp[b] = dp[a] + cost
연속부분 최대합 → 이전(dp[i-1]) 사용
모두 문제 규칙에서 나온 것.
혼란 포인트 정리
지금:
"왜 dp[i-1]인지 dp[i-2]인지
왜 이 공식인지 이유 없이 튀어나온 것처럼 보였다.”
알려준 것처럼:
문제의 “도착 규칙”
문제의 “이동 가능 규칙”
문제의 “연속성 규칙”
이것 때문에 dp[i-1]과 dp[i-2]가 사용되는 것이다.
이해됐지?
그럼 이제 연습 3문제(including 5개 중 1) 줄게
(너가 원하는 "간단한 DP 5개" 중 첫 번째)
문제 1: 계단 오르기 최소 비용
각 계단마다 cost가 있고
한 번에 1 or 2 계단 올라갈 수 있다.
예:
cost = [3, 4, 1, 2]
최소 비용은?
이 문제의 공식은?
dp[i] = min(dp[i-1], dp[i-2]) + cost[i]


--편집거리 글자 맞추기 
연산	의미	참조하는 이전 상태
삭제(Delete)	    A의 마지막 글자 제거	dp[i-1][j]
삽입(Insert)	    B의 마지막 글자 생성	dp[i][j-1]
교체(Replace)	A[i-1] → B[j-1]	    dp[i-1][j-1]


---
그럼 “그리드(격자)에서 최소 비용 경로”는 뭐야?
1) 그래프 구조가 나오면 → 다익스트라(또는 BFS)
2) “배열 인덱스를 변화하면서 최적값 쌓는 구조” → DP
   예:
   1 3 1
   2 5 1
   4 2 1
   여기서 최소 비용 경로 구하기는
   DP로도 풀리고, 다익스트라로도 풀려.
   왜?
   이동 방향이 오직 오른쪽/아래만 가능하다면 → DP로 해결 가능
   이동이 상/하/좌/우 가능한 일반 그래프면 → DP로는 못 함, 다익스트라만 가능
   즉,
   방향이 제한된 격자 → DP 가능
   방향이 자유로운 격자 → 다익스트라만 가능
